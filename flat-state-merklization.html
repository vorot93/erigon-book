<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Merklization of flat state - Erigon Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="mdbx.html"><strong aria-hidden="true">1.</strong> Why MDBX is our storage engine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mdbx-freelist.html"><strong aria-hidden="true">1.1.</strong> Freelist</a></li><li class="chapter-item expanded "><a href="mdbx-dupsort.html"><strong aria-hidden="true">1.2.</strong> DupSort feature explanation</a></li></ol></li><li class="chapter-item expanded "><a href="downloader-design.html"><strong aria-hidden="true">2.</strong> Downloader design</a></li><li class="chapter-item expanded "><a href="flat-state-merklization.html" class="active"><strong aria-hidden="true">3.</strong> Merklization of flat state</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Erigon Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="merklization-of-flat-state"><a class="header" href="#merklization-of-flat-state">Merklization of flat state</a></h1>
<p>Ethereum network produces checkpoints of the Ethereum State after every block. These checkpoints come in a form of
32-byte binary string, which is the root hash of the Merkle tree constructed out of the accounts in the state. This root
hash is often referred to as &quot;State root&quot;. It is part of block header, and is contained in the field <code>Root</code> of the type
<code>Header</code> <a href="../../core/types/block.go">core/types/block.go</a></p>
<p>Prior to Byzantium release, the state root was also part of every transaction receipt, and was contained in the
field <code>PostState</code>
of the type <code>Receipt</code> <a href="../../core/types/receipt.go">core/types/receipt.go</a>.</p>
<p>To keep the Merkle Patricia trie of Ethereum state balanced, all the keys (either addresses of Ethereum accounts and
contracts, or storage positions within contract storage) are converted into their respective hashes using <code>Keccak256</code>
hash function.
<code>PlainStateBucket</code> stores state with keys before hashing, <code>CurrentStateBucket</code> store same data but keys are hashed.</p>
<h2 id="hexary-radix-patricia-tree"><a class="header" href="#hexary-radix-patricia-tree">Hexary radix &quot;Patricia&quot; tree</a></h2>
<p>Ethereum uses hexary (radix == 16) radix tree to guide the algorithm of computing the state root. For the purposes of
illustrations, we will use trees with radix 4 (because radix 16 requires many more items for &quot;interesting&quot; features to
appear). We start from a set of randomly looking keys, 2 bytes (or 8 quaternary digits) each.</p>
<p><img src="pics/prefix_groups_1.png" alt="prefix_groups_1" /></p>
<p>Next, we sort them in lexicographic order.</p>
<p><img src="pics/prefix_groups_2.png" alt="prefix_groups_2" /></p>
<p>Next, we introduce the notion of a prefix group. Collection of adjacent keys form a prefix group if these keys share the
same prefix, and no other keys share this prefix. Here are the prefix groups for our example:</p>
<p><img src="pics/prefix_groups_3.png" alt="prefix_groups_3" /></p>
<p>The entire collection of keys form one implicit prefix group, with the empty prefix.</p>
<p>Merkle Patricia tree hashing rules first remove redundant parts of each key within groups, making key-value pairs
so-called &quot;leaf nodes&quot;. To produce the hash of a leaf node, one applies the hash function to the two-piece RLP (
Recursive Length Prefix). The first piece is the representation of the non-redundant part of the key. And the second
piece is the representation of the leaf value corresponding to the key, as shown in the member function <code>hashChildren</code>
of the type <code>hasher</code> <a href="../../turbo/trie/hasher.go">turbo/trie/hasher.go</a>, under the <code>*shortNode</code> case.</p>
<p>Hashes of the elements within a prefix group are combined into so-called &quot;branch nodes&quot;. They correspond to the
types <code>duoNode</code> (for prefix groups with exactly two elements) and <code>fullNode</code> in the
file <a href="../../turbo/trie/node.go">turbo/trie/node.go</a>. To produce the hash of a branch node, one represents it as an array
of 17 elements (17-th element is for the attached leaf, if exists). The positions in the array that do not have
corresponding elements in the prefix group are filled with empty strings. This is shown in the member
function <code>hashChildren</code> of the type <code>hasher</code> <a href="../../turbo/trie/hasher.go">turbo/trie/hasher.go</a>, under the <code>*duoNode</code>
and
<code>*fullNode</code> cases.</p>
<p>Sometimes, nested prefix groups have longer prefixes than 1-digit extension of their encompassing prefix group, as it is
the case in the group of items <code>12, 13</code> or in the group of items <code>29, 30, 31</code>. Such cases give rise to so-called &quot;
extension nodes&quot;. However, the value in an extension node is always the representation of a prefix group, rather than a
leaf. To produce the hash of an extension node, one applies the hash function to the two-piece RLP. The first piece is
the representation of the non-redundant part of the key. The second part is the hash of the branch node representing the
prefix group. This shown in the member function <code>hashChildren</code> of the
type <code>hasher</code> <a href="../../turbo/trie/hasher.go">turbo/trie/hasher.go</a>, under the <code>*shortNode</code> case.</p>
<p>This is the illustration of resulting leaf nodes, branch nodes, and extension nodes for our example:</p>
<p><img src="pics/prefix_groups_4.png" alt="prefix_groups_4" /></p>
<h2 id="separation-of-keys-and-the-structure"><a class="header" href="#separation-of-keys-and-the-structure">Separation of keys and the structure</a></h2>
<p>Our goal here will be to construct an algorithm that can produce the hash of the Merkle Patricia Tree of a sorted
sequence of key-value pair, in one simple pass (i.e. without look-aheads and buffering, but with a stack). Another
goal (perhaps more important)
is to be able to split the sequence of key-value pairs into arbitrary chunks of consecutive keys, and reconstruct the
root hash from hashes of the individual chunks (note that a chunk might need to have more than one hash).</p>
<p>Let's say that we would like to split the ordered sequence of 32 key-value pairs into 4 chunks, 8 pairs in each. We
would then like to compute the hashes (there might be more than one hash per chunk) of each chunk separately. After
that, we would like to combine the hashes of the chunks into the root hash.</p>
<p>Our approach would be to generate some additional information, which we will call &quot;structural information&quot;, for each
chunk, as well as for the composition of chunks. This structural information can be a sequence of these &quot;opcodes&quot;:</p>
<ol>
<li><code>LEAF length-of-key</code></li>
<li><code>LEAFHASH length-of-key</code></li>
<li><code>EXTENSION key</code></li>
<li><code>EXTENSIONHASH key</code></li>
<li><code>BRANCH set-of-digits</code></li>
<li><code>BRANCHHASH set-of-digits</code></li>
<li><code>HASH number-of-hashes</code></li>
</ol>
<p>The description of semantics will require the introduction of two stacks, which always have the same length. One of the
stacks (we call it &quot;hash stack&quot;) contains hashes produced by opcodes. Another stack (we call it &quot;node stack&quot;)
contains leaf nodes, branch nodes, or extension nodes of the trie being built. In some cases, where the presence of a
node is not required, the corresponding entry in the node stack is empty, or <code>nil</code>. As well as the stack, the
description requires the introduction of two input sequences (or &quot;tapes&quot;). The first tape contains key-value pairs, each
pair can be viewed as two opaque binary strings of arbitrary length, usually with the requirement that the whole
sequence is sorted by the lexicographic order of the keys, and all the keys are distinct. The second tape contains
hashes, each 32 bytes long.</p>
<p>N.B. Though there two stacks, we can sometimes just say &quot;the stack&quot;, since they are always of the same size and are
operated upon in unison. For example, when we say that XXX pops something from the stack, we mean that XXX pops 1 item
from the hash stack and 1 item from the node stack, but then only one of those two items may be used later and the other
may be discarded by XXX.</p>
<p><code>LEAF</code> opcode consumes the next key-value pair from the first tape, creates a new leaf node and pushes it onto the node
stack. It also pushes the hash of that node onto the hash stack. The operand
<code>length-of-key</code> specifies how many digits of the key become part of the leaf node. For example, for the leaf <code>11</code>
in our example, it will be 6 digits, and for the leaf <code>12</code>, it will be 4 digits. Special case of <code>length-of-key</code>
being zero, pushes the value onto the stack and discards the key.</p>
<p><code>LEAFHASH</code> has almost the same semantics as <code>LEAF</code>, with the difference that it does not need to produce the leaf node,
but only its hash (which can be more efficient in terms of allocations). It places <code>nil</code> onto the node stack.</p>
<p><code>EXTENSION</code> opcode has a key as its operand. This key is a sequence of digits, which, in our example, can only be of
length 1, but generally, it can be longer. The action of this opcode is to pop one item from the stack, create an
extension node with the key provided in the operand, and the value being the item popped from the stack, and push this
extension node onto the node stack (and push its hash onto the hash stack).</p>
<p><code>EXTENSIONHASH</code> has almost the same semantics as <code>EXTENSION</code>, with the difference that it does not need to produce the
extension node, but only its hash (which can be more efficient in terms of allocations). It places <code>nil</code> onto the node
stack.</p>
<p><code>BRANCH</code> opcode has a set of hex digits as its operand. This set can be encoded as a bitset, for example. The action of
this opcode is to pop the same number of items from the stack as the number of digits in the operand's set, create a
branch node, and push it onto the node stack (and push its hash onto the hash stack). Sets of digits can be seen as the
horizontal rectangles on the picture <code>prefix_groups_4</code>. The correspondence between digits in the operand's set and the
items popped from the stack is as follows. The top of the stack (the item being popped off first)
corresponds to the highest digit, and the item being popped off last corresponds to the lowest digit in the set.</p>
<p><code>BRANCHHASH</code> opcode is similar to the <code>BRANCH</code> with the difference is that instead of constructing the branch node, it
only creates its 32-byte hash. It places hash of the node onto the hash stack, and <code>nil</code> onto the node stack.</p>
<p><code>HASH</code> opcode takes specified number of hashes from the input sequence (tape) of hashes, and places them on the hash
stack. It also places the same number of <code>nil</code> entries onto the node stack. The first item consumed ends up the deepest
on the stack, the last item consumed ends up on the top of the stack.</p>
<p>This is the structural information for the chunk containing leaves from <code>0</code> to <code>7</code> (inclusive):</p>
<pre><code>LEAF 5
LEAF 5
BRANCH 12
LEAF 5
LEAF 5
LEAF 5
BRANCH 023
LEAF 6
LEAF 6
BRANCH 0123
LEAF 5
</code></pre>
<p>After executing these opcodes against the chunk, we will have 2 items on the stack, first representing the branch node (
or its hash) for the prefix group of leaves <code>0</code> to <code>6</code>, and the second representing one leaf node for the leaf
<code>7</code>. It can be observed that if we did not see what the next key after the leaf <code>7</code> is, we would not know the operand
for the last <code>LEAF</code> opcode. If the next key started with the prefix <code>101</code> instead of <code>103</code>, the last opcode could have
been <code>LEAF 4</code> (because leaves <code>7</code> and <code>8</code> would have formed a prefix group).</p>
<p>After hashing the first chunk, the tree would look as follows.
<img src="pics/prefix_groups_5.png" alt="prefix_groups_5" /></p>
<p>If we apply the same to produce the next chunk of 8 leaves, we will get to the following picture.
<img src="pics/prefix_groups_6.png" alt="prefix_groups_6" /></p>
<p>And, after hashing the two remaining chunks.
<img src="pics/prefix_groups_7.png" alt="prefix_groups_7" /></p>
<p>Now, if we were given the sequence of these hashes, we need to combine them to produce the root hash.</p>
<pre><code>HASH 3
BRANCH 13
HASH 5
BRANCH 12
HASH 1
BRANCH 01
BRANCH 03
BRANCH 0123
HASH 5
BRANCH 012
BRANCH 013
HASH 1
BRANCH 0123
</code></pre>
<p>These opcodes are implemented by the type <code>HashBuilder</code> (implements the interface <code>structInfoReceiver</code>)
in <a href="../../turbo/trie/hashbuilder.go">turbo/trie/hashbuilder.go</a></p>
<h2 id="multiproofs"><a class="header" href="#multiproofs">Multiproofs</a></h2>
<p>Encoding structural information separately from the sequences of key-value pairs and hashes allows describing
so-called &quot;multiproofs&quot;. Suppose that we know the root hash of the sequence of key-value pairs for our example, but we
do not know any of the pairs themselves. And we ask someone to reveal keys and value for the leaves <code>3</code>, <code>8</code>, <code>22</code>
and <code>23</code>, and enough information to prove to us that the revealed keys and values indeed belong to the sequence. Here is
the picture that gives the idea of which hashes need to be provided together with the selected key-value pairs.
<img src="pics/prefix_groups_8.png" alt="prefix_groups_8" /></p>
<p>And here is the corresponding structural information:</p>
<pre><code>HASH 2
LEAF 5
HASH 1
BRANCH 023
HASH 2
BRANCH 0123
HASH 1
LEAF 4
HASH 2
BRANCH 023
HASH 3
BRANCH 0123
HASH 2
LEAF 5
LEAF 5
BRANCH 012
BRANCH 013
BRANCH 0123
</code></pre>
<p>We can think of a multiproof as the combination of 3 things:</p>
<ol>
<li>Sequence of those 4 key-value pairs</li>
<li>Sequence of 15 hashes</li>
<li>Structural information that lets us compute the root hash out of the sequences (1) and (2)</li>
</ol>
<h2 id="generating-the-structural-information-from-the-sequence-of-keys"><a class="header" href="#generating-the-structural-information-from-the-sequence-of-keys">Generating the structural information from the sequence of keys</a></h2>
<p>In order to devise an algorithm for generating the structural information, we return to this picture
<img src="pics/prefix_groups_3.png" alt="prefix_groups_3" /></p>
<p>It can then be readily observed that the first item in any prefix group has this property that its common prefix with
the item immediately to the right (or empty string if the item is the very last) is longer than its common prefix with
the item immediately to the left (or empty string if the item is the very first). Analogously, the last item in any
prefix group has the property that its common prefix with the item immediately to the left is longer than its common
prefix with the item immediately to the right.</p>
<p>The algorithm proceeds in steps, one step for each key-value pair, in the lexicographic order of the keys. At each step,
it observes two keys (sequences of digits) - current, and succeeding. Because the algorithm emits opcodes that
manipulate the stack (technically, two stacks, but because they are always of the same lengths, we can just say &quot;stack&quot;)
, it keeps track of what is currently on the stack. Each prefix group which is currently being
&quot;assembled&quot; by the algorithm, has some number of items on the stack. This is being tracked by an item in the <code>groups</code>
slice. The index of the item in the slice is equal to the length of the prefix of the prefix group. And the <code>uint16</code>
value of the item is the bitmask, with one bit per digit (and also per item on the stack). Whenever the algorithm emits
an opcode that would push something on the stack, one of the items in the <code>groups</code> slice gains one extra bit to its
bitmask. When the algorithm emits an opcode that would pop one or more things from the stack, the corresponding item
gets removed from the <code>groups</code> slice. The slice <code>groups</code> is started off empty and it is shared between steps.
Algorithm's step can also be invoked recursively from another step, with current and preceding keys specified by the
caller.</p>
<p>A step starts with computing the prefix of the smallest prefix group that the current key belongs to. It is either the
common prefix of current key and the preceding key or the common prefix of current key and the succeeding key, whichever
is longer (if they are the same length, then they are also equal, so no ambiguity there). If the common prefix with the
succeeding key is longer, then the new prefix group is being created. If necessary, <code>groups</code> slice is expanded (by
adding 0 items) so that it has the same length as the common prefix.</p>
<p>The digit of the current key immediately following the max common prefix is called &quot;extra digit&quot;. The sequence of digits
of the current key following that extra digit is the remainder (which could be empty). The item in the <code>groups</code> slice
corresponding to the common prefix (basically <code>groups[len(common prefix)]</code>) is modified to include an extra bit
corresponding to the &quot;extra digit&quot;. If this step of the algorithm was invoked on a key-value pair (non-recursively),
then a <code>LEAF</code> (or <code>LEAFHASH</code>)
opcode is emitted, with the operand being the length of the remainder (zero if the remainder is empty). If the step of
the algorithm was invoked recursively, and the remainder is not empty, an <code>EXTENSION</code> (or <code>EXTENSIONHASH</code>) opcode is
emitted instead, with the operand being the remainder. For example, for leaf <code>12</code>, the lengths of the common prefix with
neighbours are 1 and 3. Therefore, this key will emit the opcode
<code>LEAF 4</code>, where 4 = 8 (original length) - 3 (max common prefix length) - 1 (one digit goes to the branch node for the
prefix group).</p>
<p>The following, optional, part of the step only happens if the common prefix of the current key and the preceding key is
longer or equal than the common prefix of the current key and the succeeding key, in other words, if at least one prefix
group needs to be &quot;closed&quot;. Closing a prefix group means first emitting opcode <code>BRANCH</code> or <code>BRANCHHASH</code>. The value for
the operand is taken from the item in the <code>groups</code> slice, which corresponds to the length of the prefix for this group.
Once value is taken, <code>groups</code> slice is trimmed to remove the used item. Secondly, closing a prefix groups means invoking
the step of the algorithm recursively
(unless the group that was closed was the one with the empty prefix, which encompasses all the keys). For that recursive
invocation, the prefix of the closed group is used as the current key, and the succeeding key simply passed on.
Preceding key is found as the prefix of the current key of the length equal of the highest index of non-zero item in
the <code>groups</code> (in other words, the longest prefix of a prefix group which would have something on the stack). During the
recursive invocation, the slice <code>groups</code>
is trimmed to match the length of the preceding key that was found.</p>
<p>We will walk through the steps of the algorithm for the leaf <code>30</code>, and then for the leaf <code>31</code>. For <code>30</code>, the key
is <code>33113123</code>. Its max common prefix with neighbours is <code>3311</code>. The common prefix with the preceding key is longer than
with the succeeding key, therefore the prefix group <code>3311</code> is being closed. The digit immediately following this prefix
is <code>3</code>. Since this is a non-recursive invocation, and the remainder <code>123</code> is 3 digits long, opcode <code>LEAF 3</code> is emitted.
The optional part of the step happens, and he opcode <code>BRANCH 23</code> (closing the prefix group) is emitted. Slice <code>groups</code>
contained the bit for <code>2</code> in the item <code>groups[4]</code> already, and another bit for <code>3</code> has been added, therefore we
have <code>23</code> as the operand. Slice <code>groups</code> gets trimmed to contain only 4 items. After that, the step gets invoked
recursively with current key being <code>3311</code>, and preceding key identified as <code>3</code> (there were no prefix group with
prefix <code>33</code> or <code>331</code> yet, this can be figured out by checking the <code>groups</code> slice, where the highest index with non-zero
item is 1).</p>
<p>In the recursive invocation of the step, max common prefix is <code>331</code>. The common prefix with the succeeding key is longer
than with the preceding key, therefore a new prefix group <code>331</code> is created. Slice <code>groups</code> gets extended to 4 items, and
the fourth item
(<code>group[3]</code>) gets item containing one bit for digit <code>1</code>. No more recursion.</p>
<p>For leaf <code>31</code> (key <code>33132002</code>), max common prefix is <code>331</code>. The common prefix with the preceding key is longer than with
the succeeding key, therefore the prefix group <code>331</code> is being closed. This is the group that was created during the step
for leaf <code>30</code> described above. The digit immediately following this prefix is <code>3</code>. Corresponding bit is added to the
item <code>groups[3]</code>. Since this is a non-recursive invocation, opcode <code>LEAF 4</code> is emitted (4 is the length of the
remainder <code>2002</code>). The optional part of the step happens, opcode <code>BRANCH 13</code> is emitted, and slice <code>group</code> is trimmed to
3 items to remove the item <code>groups[3]</code>. The step gets invoked recursively with current key being <code>331</code>, and preceding
key identified as <code>3</code> (there were no prefix group with prefix <code>33</code>).</p>
<p>In the recursive step, max common prefix is <code>3</code>. The common prefix with the preceding key is longer than with the
succeeding key, therefore the prefix group <code>3</code> is being closed. The digit immediately following this prefix is <code>3</code>. The
remainder <code>1</code> is non-empty, and since this is a recursive invocation, opcode
<code>EXTENSION 1</code> is emitted. The optional part of the step happens, opcode <code>BRANCH 023</code> is emitted for the prefix group <code>3</code>
being closed. Slice <code>groups</code> is trimmed to just 1 item. The step gets invoked recursively again, with current key
being <code>3</code>, and preceding key empty.</p>
<p>In the deeper recursive step, max common prefix is empty. Since the common prefix with the preceding key equals to the
common prefix with the succeeding key (they are both empty). The optional part of the step happens, opcode <code>BRANCH 0123</code>
is emitted, and <code>groups</code> is trimmed to become empty. No recursive invocation follows.</p>
<p>The step of this algorithm is implemented by the function <code>GenStructStep</code>
in <a href="../../turbo/trie/gen_struct_step.go">turbo/trie/gen_struct_step.go</a>.</p>
<h2 id="converting-sequence-of-keys-and-value-into-a-multiproof"><a class="header" href="#converting-sequence-of-keys-and-value-into-a-multiproof">Converting sequence of keys and value into a multiproof</a></h2>
<p>One of the biggest difference between Erigon and go-ethereum is in the way the Ethereum state is persisted in the
database. In go-ethereum, the model for persistence is Merkle Patricia tree. In Erigon, the model for persistence is
sequence of key-value pairs, where keys are either derived from account addresses, or from storage indices. In this
model, computing Merkle Patricia tree from part of data is a very commonly used operation. This operation is called &quot;
Resolution&quot; because it normally arises from a need to look up (resolve) some keys and corresponding values, and later
update them, thus requiring recomputation of the Merkle Patricia tree root.</p>
<p>We can use the concept of Multiproofs to define the resolution operation. If we have a set of key-value pairs, and we
need to &quot;resolve&quot; them, we effectively need to produce a multiproof for the given set of key-value pairs. To produce
such multiproof, we can use the algorithm for generating the structural information from the sequence of keys. However,
within the algorithm, choices need to be made between emitting <code>BRANCHHASH</code> and <code>BRANCH</code> opcodes (or, similarly,
between <code>LEAF</code> and <code>LEAFHASH</code>, and between <code>EXTENSION</code> and <code>EXTENSIONHASH</code>). Such choices are conceptually simple to
make - if max common prefix is also a prefix of any of the keys we are trying to resolve,
<code>BRANCH</code> should be emitted, otherwise, <code>BRANCHHASH</code> should be emitted. However, in order to make these choices
efficiently, the set of keys being resolved will be converted into a sorted list. Then, at each point when the algorithm
processes a key, it maintains references to two consecutive keys from that sorted list - one &quot;LTE&quot; (Less Than or Equal
to the currently processed key), and another &quot;GT&quot; (Greater Than the currently processed key). If max common prefix is
also prefix of either LTE or GT, then <code>BRANCH</code> opcode is emitted, otherwise, <code>BRANCHHASH</code> opcode is emitted. This is
implemented by the type <code>ResolveSet</code> in <a href="../../turbo/trie/resolve_set.go">turbo/trie/resolve_set.go</a></p>
<h2 id="extension-of-the-structure-to-support-contracts-with-contract-storage"><a class="header" href="#extension-of-the-structure-to-support-contracts-with-contract-storage">Extension of the structure to support contracts with contract storage</a></h2>
<p>When it is required to construct tries containing accounts as well as contract storage, and contract code, the set of
opcodes making up the structural information need to be extended by four more. Apart from that, a new input sequence (
tape) is added, containing the bytecodes of contracts.</p>
<ol start="8">
<li><code>CODE</code></li>
<li><code>CODEHASH</code></li>
<li><code>ACCOUNTLEAF length field-set</code></li>
<li><code>ACCOUNTLEAFHASH length field-set</code></li>
<li><code>EMPTYROOT</code></li>
</ol>
<p><code>CODE</code> opcode consumes the next item in the bytecode sequence, creates a code node and pushes it onto the node stack. It
also pushes the hash of the byte code onto the hash stack.</p>
<p><code>CODEHASH</code> opcode consumes the next hash from the hash sequence, pushes it onto the hash stack, and pushes <code>nil</code> into
the node stack.</p>
<p><code>ACCOUNTLEAF</code> opcode is similar to <code>LEAF</code>. It consumes the next item from the key tape. The rest of the semantics
depends on the value of the <code>field-set</code>. Field set can be respresented by a bitmask. In that case, bit 0 would
correspond to field 0, bit 1 (number 2) - to field 1, bit 2 (number 4) - to field 2. Currently, field 0 means account
nonce, field 1 means account balance, field 2 means contract storage, field 3 means contract code.</p>
<ul>
<li>If field 0 is present in the <code>field-set</code>, the opcode consumes one item from the nonce tape (tape 0), otherwise it
assumes default nonce (zero). This becomes the nonce of the newly created account/contract node.</li>
<li>If field 1 is present in the <code>field-set</code>, the opcode consumes one item from the balance tape (tape 1), otherwise it
assumes default balance (zero). This becomes the balance of the newly created account/contract node.</li>
<li>If field 2 is present in the <code>field-set</code>, the opcode pops a node from the node stack and a hash from the hash stack.
This node or hash (in this order of preference) becomes the storage of the newly created contract node. Storage root
can be empty (that would introduced by <code>EMPTYROOT</code> opcode).</li>
<li>If field 3 is present in the <code>field-set</code>, the opcode pops a code node from the node stack and a hash from the hash
stack. This node or hash (in the order of preference) becomes the code or code hash of the newly created contract
node.</li>
</ul>
<p>Out of all the information collected through the tapes and the stacks (as directed by the <code>field-set</code>), an account leaf
node is constructed and pushed onto the node stack. Its hash is pushed onto the hash stack. Field set is introduced to
make the specification of what is an account extensible in a backwards compatible way. If a new field is added to the
account in the future, it can be introduced without a need to re-encode the pre-existing structures.</p>
<p><code>ACCOUNTLEAFHASH</code> opcode's difference from <code>ACCOUNTLEAF</code> is that it does not push the leaf node onto the node stack,
pushing <code>nil</code> instead. The hash of would-be account leaf node is pushed onto the hash stack.</p>
<p><code>EMPTYROOT</code> is a way of placing a special value signifying an empty node onto the node stack. It also pushes the
corresponding hash onto the hash stack. This opcode is introduced because there is no way of achieving its semantics by
means of other opcodes.</p>
<h2 id="merkle-trie-root-calculation"><a class="header" href="#merkle-trie-root-calculation">Merkle trie root calculation</a></h2>
<p><strong>Theoretically:</strong> &quot;Merkle trie root calculation&quot; starts from state, build from state keys - trie, on each level of trie
calculates intermediate hash of underlying data.</p>
<p><strong>Practically:</strong> It can be implemented as &quot;Preorder trie traversal&quot; (Preorder - visit Root, visit Left, visit Right).
But, let's make couple observations to make traversal over huge state efficient.</p>
<p><strong>Observation 1:</strong> <code>CurrentStateBucket</code> already stores state keys in sorted way. Iteration over this bucket will
retrieve keys in same order as &quot;Preorder trie traversal&quot;.</p>
<p><strong>Observation 2:</strong> each Eth block - changes not big part of state - it means most of Merkle trie intermediate hashes
will not change. It means we effectively can cache them. <code>IntermediateTrieHashBucket</code> stores &quot;Intermediate hashes of all
Merkle trie levels&quot;. It also sorted and Iteration over <code>IntermediateTrieHashBucket</code> will retrieve keys in same order
as &quot;Preorder trie traversal&quot;.</p>
<p><strong>Implementation:</strong> by opening 1 Cursor on state and 1 more Cursor on intermediate hashes bucket - we will receive data
in order of &quot;Preorder trie traversal&quot;. Cursors will only do &quot;sequential reads&quot; and &quot;jumps forward&quot; - been
hardware-friendly. 1 stack keeps all accumulated hashes, when sub-trie traverse ends - all hashes pulled from stack -&gt;
hashed -&gt; new hash puts on stack - it's hash of visited sub-trie (it emulates recursive nature of &quot;Preorder trie
traversal&quot; algo).</p>
<p>Imagine that account with key 0000....00 (64 zeroes, 32 bytes of zeroes) changed. Here is an example sequence which can
be seen by running 2 Cursors:</p>
<pre><code>00   // key which came from cache, can't use it - because account with this prefix changed 
0000 // key which came from cache, can't use it - because account with this prefix changed
...
{30 zero bytes}00    // key which came from cache, can't use it - because account with this prefix changed
{30 zero bytes}0000  // Account which came from state, use it - calculate hash, jump to &quot;next sub-trie&quot;
{30 zero bytes}01    // key which came from cache, it is &quot;next sub-trie&quot;, use it, jump to &quot;next sub-trie&quot; 
{30 zero bytes}02    // key which came from cache, it is &quot;next sub-trie&quot;, use it, jump to &quot;next sub-trie&quot;
...
{30 zero bytes}ff    // key which came from cache, it is &quot;next sub-trie&quot;, use it, jump to &quot;next sub-trie&quot;
{29 zero bytes}01    // key which came from cache, it is &quot;next sub-trie&quot; (1 byte shorter key), use it, jump to &quot;next sub-trie&quot;
{29 zero bytes}02    // key which came from cache, it is &quot;next sub-trie&quot; (1 byte shorter key), use it, jump to &quot;next sub-trie&quot;
...
ff                   // key which came from cache, it is &quot;next sub-trie&quot; (1 byte shorter key), use it, jump to &quot;next sub-trie&quot;
nil                  // db returned nil - means no more keys there, done   
</code></pre>
<p>In practice Trie is not full - it means after account key <code>{30 zero bytes}0000</code> may come <code>{5 zero bytes}01</code> and amount of
iterations will not be big.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="downloader-design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="downloader-design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
